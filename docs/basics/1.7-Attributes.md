
---

# üìù Elixir Module Attributes Cheat Sheet

### What are Module Attributes?

* Start with `@`
* Placed **inside a module**, outside function definitions.
* Three main uses:

  1. **Annotations/metadata** (e.g., `@moduledoc`)
  2. **Compile-time constants** (e.g., `@pi`)
  3. **Custom metadata** (e.g., `@mytag`)

---

### 1. **Built-in Attributes**

These are reserved keywords:

```elixir
defmodule Math do
  @moduledoc "Provides math functions"
  @doc "Adds two numbers"
  def add(a, b), do: a + b

  @doc "Subtracts second number"
  def sub(a, b), do: a - b
end
```

* `@moduledoc` ‚Üí doc for the whole module
* `@doc` ‚Üí doc for functions/macros
* `@behaviour` ‚Üí enforce callbacks
* `@enforce_keys` ‚Üí required struct keys

---

### 2. **Constants**

Stored at **compile time**, not runtime.

```elixir
defmodule Circle do
  @pi 3.14159
  def area(r), do: @pi * r * r
end
```

* `@pi` is fixed when the module compiles.
* If you want runtime config ‚Üí use `Application.get_env/2` instead.

---

### 3. **Custom Metadata**

You can define your own attributes:

```elixir
defmodule Feature do
  @feature_flag true
  def enabled?, do: @feature_flag
end
```

---

### 4. **Accumulating Attributes**

With `Module.register_attribute/3`, attributes can **accumulate multiple values**.

```elixir
defmodule Logger do
  Module.register_attribute(__MODULE__, :tags, accumulate: true)
  @tags :debug
  @tags :error
  @tags :info

  def show_tags, do: @tags
end

Logger.show_tags() # [:debug, :error, :info]
```

---

# ‚ö° Common Use Cases

* **Docs**: `@moduledoc`, `@doc`
* **Constants**: `@pi`, `@timeout`
* **Structs**: `@enforce_keys`
* **Protocols/behaviours**: `@behaviour GenServer`
* **Custom DSLs**: Phoenix, Ecto use attributes internally for macros

---

# ‚ùì Interview Questions on Module Attributes

1. **What are the three main purposes of module attributes in Elixir?**
   ‚Üí Docs, constants, metadata.

2. **What is the difference between a module attribute constant and a variable?**
   ‚Üí Attribute is compile-time, variable is runtime.

3. **Can module attributes be changed at runtime?**
   ‚Üí No, they are evaluated at compile time.

4. **What is `@enforce_keys` used for?**
   ‚Üí To force required keys in structs at compile time.

5. **How do you make a module attribute hold multiple values?**
   ‚Üí Use `Module.register_attribute/3` with `accumulate: true`.


---

### 1. Module attributes (`@something`)

By default in Elixir:

* `@name value` is just **metadata at compile time**.
* You can later read it in the same module (compile-time constant).

Example:

```elixir
defmodule Feature do
  @feature_flag true
  def enabled?, do: @feature_flag
end
```

Here `@feature_flag` is stored during compilation, so `enabled?/0` always returns `true`.
If you edit the module and recompile (`recompile/0` in IEx or `mix compile`), the constant updates.
That‚Äôs what "compile-time constant" means.

---

### 2. Accumulating attributes

Normally, if you do this:

```elixir
defmodule A do
  @x 1
  @x 2
end
```

The second one **overwrites** the first.

But with:

```elixir
defmodule Logger do
  Module.register_attribute(__MODULE__, :tags, accumulate: true)

  @tags :debug
  @tags :error
  @tags :info

  def show_tags, do: @tags
end
```

* You‚Äôve told Elixir: "`@tags` should accumulate values".
* So instead of overwriting, Elixir collects them in a list.
* `:tags` in `register_attribute/3` refers to `@tags`. Yes, if you want `@si`, you‚Äôd register it as `:si`.

‚ö° Without `accumulate: true`, `@tags` would only hold `:info` (the last one).

---

### 3. Macros (the scary word)

* A **macro** is code that writes code at compile time.
* Functions run at runtime, but macros transform your code *before* runtime.
* That‚Äôs why `@attributes` are often used with macros, because macros need compile-time info.

Example:

```elixir
defmodule Example do
  defmacro say_hello(name) do
    quote do
      IO.puts("Hello " <> unquote(name))
    end
  end
end
```

Usage:

```elixir
require Example
Example.say_hello("Hp")
```

At compile time, this expands into `IO.puts("Hello Hp")`.

---

### 4. `@behaviour`

This is like an **interface/contract**.

Example:

```elixir
defmodule MyBehaviour do
  @callback speak(String.t()) :: String.t()
end

defmodule Dog do
  @behaviour MyBehaviour
  def speak(name), do: "Woof " <> name
end
```

* `@callback` defines required functions.
* `@behaviour` says "this module must implement them".
* Compiler will warn if you forget.

---

‚úÖ So putting it all together:

* `@attr` = compile-time constant or metadata.
* `Module.register_attribute` lets you change default behavior (like accumulating).
* `macros` use `@attrs` to generate code at compile time.
* `@behaviour` enforces a contract like an interface.

---



