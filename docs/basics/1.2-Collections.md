

---

# 📝 Elixir Data Structures Cheatsheet

### 🔹 **Lists** (linked lists)

* Can hold mixed + duplicate values.

```elixir
list = [3.14, :pie, "Apple"]

["π" | list]   # Prepend (fast)
list ++ ["Cherry"]  # Append (slow)

[1, 2] ++ [3, 4]   # [1, 2, 3, 4]
[1, 2, 2, 3] -- [2, 3]  # [1, 2]
```

* Head & Tail:

```elixir
[head | tail] = [1, 2, 3]
# head = 1, tail = [2, 3]
```

---

### 🔹 **Tuples**

* Fixed-size, fast access, costly modification.

```elixir
tuple = {3.14, :pie, "Apple"}

# Common in return values:
File.read("file.txt")
# {:ok, "contents"} or {:error, :enoent}
```

---

### 🔹 **Keyword Lists**

* A special list of 2-element tuples where **keys are atoms**.
* Ordered, non-unique keys. Often for **options**.

```elixir
opts = [foo: "bar", hello: "world"]
# same as [{:foo, "bar"}, {:hello, "world"}]

opts[:foo]  # "bar"
```

---

### 🔹 **Maps**

* Key-value store, unordered, allows any key type.

```elixir
map = %{:foo => "bar", "hello" => :world}

map[:foo]     # "bar"
map["hello"]  # :world
map.hello     # "world" (only atom keys!)
```

* Updating:

```elixir
map = %{foo: "bar"}
%{map | foo: "baz"}   # %{foo: "baz"}

# Add new key
Map.put(map, :new, 123)  # %{foo: "bar", new: 123}
```

* Atom-key shorthand:

```elixir
%{foo: "bar"} == %{:foo => "bar"}  # true
```

---

⚡ **Rules of Thumb**

* **Lists** → ordered collections, recursion, prepend is cheap.
* **Tuples** → fixed grouping, often return values.
* **Keyword Lists** → options to functions.
* **Maps** → general key-value store, updates, lookups.

---
