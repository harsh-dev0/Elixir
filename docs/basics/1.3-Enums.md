

---

# 🔑 Enum Cheatsheet (Elixir)

### **Overview**

* Works on **enumerables** (lists, maps, ranges, etc. but not tuples).
* Returns new collections (except `each`).
* Functional style: always **immutable**.

---

### **Common Functions**

**1. all?/2** → checks if all elements satisfy condition

```elixir
Enum.all?(["foo", "bar"], fn s -> String.length(s) == 3 end)
# true
```

**2. any?/2** → true if at least one matches

```elixir
Enum.any?(["foo", "hello"], fn s -> String.length(s) == 5 end)
# true
```

**3. each/2** → run side effects, returns `:ok`

```elixir
Enum.each(["one", "two"], fn s -> IO.puts(s) end)
# prints one, two
```

**4. map/2** → transform each element

```elixir
Enum.map([1, 2, 3], fn x -> x * 2 end)
# [2, 4, 6]
```

**5. min/1, max/1** → smallest / largest element

```elixir
Enum.min([5, 3, 0]) # 0
Enum.max([5, 3, 0]) # 5
```

**6. filter/2** → keep only matching elements

```elixir
Enum.filter([1,2,3,4], fn x -> rem(x, 2) == 0 end)
# [2, 4]
```

**7. reduce/3** → fold into a single value

```elixir
Enum.reduce([1,2,3], 10, fn x, acc -> x + acc end)
# 16
```

**8. sort/2** → sort ascending/descending or custom

```elixir
Enum.sort([3,1,2], :desc)
# [3, 2, 1]
```

**9. uniq/1, uniq\_by/2** → remove duplicates

```elixir
Enum.uniq([1,2,2,3]) # [1,2,3]
```

**10. chunk\_every/2** → split into groups

```elixir
Enum.chunk_every([1,2,3,4,5], 2)
# [[1,2],[3,4],[5]]
```

**11. chunk\_by/2** → group by condition

```elixir
Enum.chunk_by(["one","two","three"], &String.length/1)
# [["one","two"], ["three"]]
```

**12. map\_every/3** → apply fn every nth item

```elixir
Enum.map_every([1,2,3,4,5,6], 2, &(&1+100))
# [101,2,103,4,105,6]
```

---

### **Capture Operator (&)**

Shorthand for anonymous functions:

```elixir
Enum.map([1,2,3], &(&1 + 3))
# [4,5,6]

Enum.map([1,2,3], &Integer.to_string/1)
# ["1","2","3"]
```

---

⚡️ **Memory Trick for Interview**

* **all? / any?** → Boolean checks
* **map / filter** → transform vs reduce size
* **reduce** → collapse into single
* **each** → side effects
* **sort / uniq / chunk** → collection restructuring

Interview-ready summary

!: raises error instead of returning {:error, reason}.

?: returns boolean, used for predicates.

/arity: way to reference functions by argument count.

---

### `Enum.uniq_by/2`

* **What it does**: Removes duplicates, but *instead of comparing the whole element*, it decides uniqueness based on a function you give it.
* **Signature**:

  ```elixir
  Enum.uniq_by(enumerable, fun)
  ```

  * `enumerable` → list, map, etc.
  * `fun` → function that extracts the “key” for comparison.

---

### Example

```elixir
Enum.uniq_by([%{x: 1, y: 1}, %{x: 2, y: 1}, %{x: 3, y: 3}], fn coord -> coord.y end)
```

* Step 1: List = `[ %{x: 1, y: 1}, %{x: 2, y: 1}, %{x: 3, y: 3} ]`

* Step 2: Function = `fn coord -> coord.y end` → picks the `y` value for uniqueness check.

* First element: `%{x: 1, y: 1}` → `y = 1` → keep it.

* Second element: `%{x: 2, y: 1}` → `y = 1` → already seen → skip.

* Third element: `%{x: 3, y: 3}` → `y = 3` → new → keep.

✅ Result: `[ %{x: 1, y: 1}, %{x: 3, y: 3} ]`

---

### When to Use

* You want to **remove duplicates by a specific field**.
* Example in a project (say, **InVideo AI clone**):

  ```elixir
  # You fetched video drafts, but some users have multiple drafts with same title
  drafts = [
    %{id: 1, user_id: 10, title: "Intro Video"},
    %{id: 2, user_id: 11, title: "Intro Video"},
    %{id: 3, user_id: 12, title: "Final Cut"}
  ]

  Enum.uniq_by(drafts, fn d -> d.title end)
  # => keeps only one "Intro Video" and "Final Cut"
  ```

---

