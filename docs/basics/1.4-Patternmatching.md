

---

### 📌 Pattern Matching (`=`)

* `=` is not assignment. It’s **match + bind**.

  ```elixir
  x = 1        # x bound to 1
  1 = x        # ✅ matches (both 1)
  2 = x        # ❌ MatchError
  {a, b} = {1, 2}   # a=1, b=2
  ```

---

### 📌 Pin Operator (`^`)

* Stops rebinding, forces **match against existing value**.

  ```elixir
  x = 1
  ^x = 1     # ✅ ok
  ^x = 2     # ❌ MatchError
  ```

---

### 📌 Underscore (`_`)

* Wildcard, ignores value.

  ```elixir
  {_, y} = {1, 2}   # y=2, first ignored
  ```

---

### 📌 Function heads + Pattern Matching

* Functions can have multiple clauses.

  ```elixir
  def greet({:ok, name}), do: "Hi #{name}"
  def greet(:error), do: "Error"
  ```

---

### 📌 Guards

* Add conditions on top of pattern matching.

  ```elixir
  def classify(x) when is_integer(x) and x > 0, do: "positive int"
  def classify(_), do: "other"
  ```

---

### 📌 `!` and `?` naming

* Convention:

  * `!` → function may raise error (`File.read!/1`)
  * `?` → predicate, returns boolean (`Enum.empty?/1`)

---

“Elixir uses the match operator `=` for pattern matching, not assignment. The left side is a pattern, and variables get bound if the right side matches. If already bound, use the pin operator `^` to force exact match. `_` ignores values. Pattern matching powers function clauses and guards. `!` marks dangerous functions that raise, `?` marks predicates.”

---

Pipe Operator (|>) in Elixir

It’s just syntax sugar to pass the result of one expression as the first argument to the next function.

Example without pipe:
String.upcase(String.trim("  hello  "))

Example with pipe:
"  hello  "
|> String.trim()
|> String.upcase()


Both give "HELLO".

Why it exists?

Makes code more readable.

Functions are read top to bottom, like a flow.

Eliminates nested parentheses.

Rule
value |> fun(a, b)


is the same as:

fun(value, a, b)

Quick Interview Example
[1, 2, 3, 4, 5]
|> Enum.filter(&rem(&1, 2) == 0)   # keep evens
|> Enum.map(&(&1 * &1))            # square them


Result: [4, 16]