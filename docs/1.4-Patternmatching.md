

---

### 📌 Pattern Matching (`=`)

* `=` is not assignment. It’s **match + bind**.

  ```elixir
  x = 1        # x bound to 1
  1 = x        # ✅ matches (both 1)
  2 = x        # ❌ MatchError
  {a, b} = {1, 2}   # a=1, b=2
  ```

---

### 📌 Pin Operator (`^`)

* Stops rebinding, forces **match against existing value**.

  ```elixir
  x = 1
  ^x = 1     # ✅ ok
  ^x = 2     # ❌ MatchError
  ```

---

### 📌 Underscore (`_`)

* Wildcard, ignores value.

  ```elixir
  {_, y} = {1, 2}   # y=2, first ignored
  ```

---

### 📌 Function heads + Pattern Matching

* Functions can have multiple clauses.

  ```elixir
  def greet({:ok, name}), do: "Hi #{name}"
  def greet(:error), do: "Error"
  ```

---

### 📌 Guards

* Add conditions on top of pattern matching.

  ```elixir
  def classify(x) when is_integer(x) and x > 0, do: "positive int"
  def classify(_), do: "other"
  ```

---

### 📌 `!` and `?` naming

* Convention:

  * `!` → function may raise error (`File.read!/1`)
  * `?` → predicate, returns boolean (`Enum.empty?/1`)

---

“Elixir uses the match operator `=` for pattern matching, not assignment. The left side is a pattern, and variables get bound if the right side matches. If already bound, use the pin operator `^` to force exact match. `_` ignores values. Pattern matching powers function clauses and guards. `!` marks dangerous functions that raise, `?` marks predicates.”

---

