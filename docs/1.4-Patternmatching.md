

---

### ğŸ“Œ Pattern Matching (`=`)

* `=` is not assignment. Itâ€™s **match + bind**.

  ```elixir
  x = 1        # x bound to 1
  1 = x        # âœ… matches (both 1)
  2 = x        # âŒ MatchError
  {a, b} = {1, 2}   # a=1, b=2
  ```

---

### ğŸ“Œ Pin Operator (`^`)

* Stops rebinding, forces **match against existing value**.

  ```elixir
  x = 1
  ^x = 1     # âœ… ok
  ^x = 2     # âŒ MatchError
  ```

---

### ğŸ“Œ Underscore (`_`)

* Wildcard, ignores value.

  ```elixir
  {_, y} = {1, 2}   # y=2, first ignored
  ```

---

### ğŸ“Œ Function heads + Pattern Matching

* Functions can have multiple clauses.

  ```elixir
  def greet({:ok, name}), do: "Hi #{name}"
  def greet(:error), do: "Error"
  ```

---

### ğŸ“Œ Guards

* Add conditions on top of pattern matching.

  ```elixir
  def classify(x) when is_integer(x) and x > 0, do: "positive int"
  def classify(_), do: "other"
  ```

---

### ğŸ“Œ `!` and `?` naming

* Convention:

  * `!` â†’ function may raise error (`File.read!/1`)
  * `?` â†’ predicate, returns boolean (`Enum.empty?/1`)

---

â€œElixir uses the match operator `=` for pattern matching, not assignment. The left side is a pattern, and variables get bound if the right side matches. If already bound, use the pin operator `^` to force exact match. `_` ignores values. Pattern matching powers function clauses and guards. `!` marks dangerous functions that raise, `?` marks predicates.â€

---

